/**
 * This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!
 */

#ifndef JSONRPC_CPP_STUB_FARMCLIENT_H_
#define JSONRPC_CPP_STUB_FARMCLIENT_H_

#include <jsonrpccpp/client.h>
#include <libethash/sha3_cryptopp.h>
#include <libethcore/Transaction.h>


//#define TOKEN_CONTRACT "0xb6ed7644c69416d67b522e20bc294a9a9b405b31"	// main net
#define TOKEN_CONTRACT "0x48354a052CDd707B909daE507aD7F6E2DC065082"		// ETC test contract

class FarmClient : public jsonrpc::Client
{
    public:
        FarmClient(jsonrpc::IClientConnector &conn, jsonrpc::clientVersion_t type = jsonrpc::JSONRPC_CLIENT_V2) : jsonrpc::Client(conn, type) {}

		void testTransaction() {
			TransactionSkeleton t;
			t.data = fromHex("");
			t.nonce = u256(1);
			t.to = toAddress("");
			t.gas = u256(10);
			t.gasPrice = u256(10);

			Secret s = getSecret(m_signKey);
			TransactionBase tx = TransactionBase(t);
			tx.
		}

        Json::Value eth_getWork() throw (jsonrpc::JsonRpcException)
        {
            Json::Value p;
            p = Json::nullValue;
            Json::Value result = this->CallMethod("eth_getWork",p);
            if (result.isArray())
                return result;
            else
                throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
        }

		void eth_getWork_token(h256& _challenge, h256& _target) throw (jsonrpc::JsonRpcException)
		{
			// challenge
			Json::Value p;
			p["from"] = MINER_ACCOUNT;			// ETH address (Jaxx HD)
			p["to"] = TOKEN_CONTRACT;			// 0xbitcoin contract address
			h256 bMethod = sha3("getChallengeNumber()");
			std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
			p["data"] = sMethod.substr(0, 10);

			Json::Value data;
			data.append(p);
			data.append("latest");

			Json::Value result = this->CallMethod("eth_call", data);
			if (result.isString()) {
				_challenge = h256(result.asString());
			}
			else
				throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

			// target
			bMethod = sha3("getMiningTarget()");
			sMethod = toHex(bMethod, dev::HexPrefix::Add);
			p["data"] = sMethod.substr(0, 10);

			data.clear();
			data.append(p);
			data.append("latest");

			result = this->CallMethod("eth_call", data);
			if (result.isString()) {
				_target = h256(result.asString());
			} else
				throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

		}

		void testHash()  throw (jsonrpc::JsonRpcException)
		{
			std::ostringstream ss;
			Json::Value p;
			p["from"] = MINER_ACCOUNT;		// ETH address (Jaxx HD)
			p["to"] = TOKEN_CONTRACT;		// 0xbitcoin contract address

			h256 bMethod = sha3("getMintDigest(uint256,bytes32,bytes32)");
			std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
			sMethod = sMethod.substr(0, 10);

			h256 nonce = h256::random();
			ss << std::setw(64) << std::setfill('0') << nonce.hex();
			std::string s2(ss.str());

			sMethod = sMethod + s2;
			
			// unused parameter
			sMethod = sMethod + s2;

			h256 challenge = h256::random();
			ss = std::ostringstream();
			ss << std::setw(64) << std::setfill('0') << challenge.hex();
			s2 = std::string(ss.str());
			sMethod = sMethod + s2;

			p["data"] = sMethod;

			Json::Value data;
			data.append(p);
			data.append("latest");

			Json::Value result = this->CallMethod("eth_call", data);
			if (result.isString()) {
				LogS << "test hash";
				LogS << result.asString();

				h160 sender(MINER_ACCOUNT);
				std::vector<byte> mix(84);
				memcpy(&mix[0], challenge.data(), 32);
				memcpy(&mix[32], sender.data(), 20);
				memcpy(&mix[52], nonce.data(), 32);
				h256 hash[2];
				SHA3_256((const ethash_h256_t*) hash, (const uint8_t*) mix.data(), 84);
				LogS << "0x" << hash[0];
				LogS << "end test";

			} else
				throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
		}

		void testSubmitSolution() throw (jsonrpc::JsonRpcException) 
		{
			std::ostringstream ss;
			Json::Value p;
			p["from"] = MINER_ACCOUNT;		// ETH address (Jaxx HD)
			p["to"] = TOKEN_CONTRACT;		// 0xbitcoin contract address
			p["gas"] = "0x030D40";	// 200,000 gwei
			p["gasPrice"] = "0x012A05F200";   // 5 gwei

			h256 bMethod = sha3("mint(uint256,bytes32)");
			std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
			sMethod = sMethod.substr(0, 10);

			h256 nonce = h256::random();
			ss << std::setw(64) << std::setfill('0') << nonce.hex();
			std::string s2(ss.str());

			sMethod = sMethod + s2;

			h256 challenge = h256::random();
			ss = std::ostringstream();
			ss << std::setw(64) << std::setfill('0') << challenge.hex();
			s2 = std::string(ss.str());
			sMethod = sMethod + s2;

			p["data"] = sMethod;

			Json::Value data = Json::Value(Json::arrayValue);
			data.append(p);

			LogS << data;

			try 				
			{
				Json::Value result = this->CallMethod("eth_sendTransaction", data);
				if (result.isString()) {
					LogS << "test solution";
					LogS << result.asString();
				}
			}
			catch (jsonrpc::JsonRpcException& e) {
				LogS << e.what();
			}

		}

		bool eth_submitWork(const std::string& param1, const std::string& param2, const std::string& param3) throw (jsonrpc::JsonRpcException)
        {
            Json::Value p;
            p.append(param1);
            p.append(param2);
            p.append(param3);
            Json::Value result = this->CallMethod("eth_submitWork",p);
            if (result.isBool())
                return result.asBool();
            else
                throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
        }

		bool eth_submitWorkToken(h256 _nonce, h256 _challenge) throw (jsonrpc::JsonRpcException) {
			Json::Value p;
			Json::Value result = this->CallMethod("eth_submitWork", p);
			if (result.isBool())
				return result.asBool();
			else
				throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
		}

        bool eth_submitHashrate(const std::string& param1, const std::string& param2) throw (jsonrpc::JsonRpcException)
        {
            Json::Value p;
            p.append(param1);
            p.append(param2);
            Json::Value result = this->CallMethod("eth_submitHashrate",p);
            if (result.isBool())
                return result.asBool();
            else
                throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
        }

        Json::Value eth_awaitNewWork() throw (jsonrpc::JsonRpcException)
        {
            Json::Value p;
            p = Json::nullValue;
            Json::Value result = this->CallMethod("eth_awaitNewWork",p);
            if (result.isArray())
                return result;
            else
                throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
        }

        bool eth_progress() throw (jsonrpc::JsonRpcException)
        {
            Json::Value p;
            p = Json::nullValue;
            Json::Value result = this->CallMethod("eth_progress",p);
            if (result.isBool())
                return result.asBool();
            else
                throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
        }

};

#endif //JSONRPC_CPP_STUB_FARMCLIENT_H_
