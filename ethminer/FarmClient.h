/**
* This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!
*/

#ifndef JSONRPC_CPP_STUB_FARMCLIENT_H_
#define JSONRPC_CPP_STUB_FARMCLIENT_H_

#include <jsonrpccpp/client.h>
#include <ethminer/SignTx.h>
#include <libethash/sha3_cryptopp.h>

using namespace std;
using namespace dev;
using namespace dev::eth;

//#define TOKEN_CONTRACT "0xb6ed7644c69416d67b522e20bc294a9a9b405b31"	// main net
#define TOKEN_CONTRACT "0x48354a052CDd707B909daE507aD7F6E2DC065082"		// ETC test contract

class FarmClient : public jsonrpc::Client
{
public:
	FarmClient(jsonrpc::IClientConnector &conn, jsonrpc::clientVersion_t type = jsonrpc::JSONRPC_CLIENT_V2) : jsonrpc::Client(conn, type) {}

	void testTransaction() {

		// get transaction count for nonce
		Json::Value p;
		p.append(MINER_ACCOUNT);
		p.append("latest");
		Json::Value result = this->CallMethod("eth_getTransactionCount", p);
		std::istringstream converter(result.asString());
		int nonce;
		converter >> std::hex >> nonce;

		// prepare transaction
		Transaction t;
		t.nonce = nonce;
		t.receiveAddress = toAddress("0x29224Be72851D7Bad619f64c2E51E8Ca5Ba1094b");
		t.gas = u256(21000);
		t.gasPrice = u256(10000000000);
		t.data = fromHex("");
		t.value = 4000000000;
		Secret pk = Secret("d1ced27471f165c1d42b2e225c416125fa998900a2865b2168686c34e5520e24");
		t.sign(pk);
		stringstream ss;
		ss << "0x" << toHex(t.rlp());

		// submit to the node
		p.clear();
		p.append(ss.str());
		result = this->CallMethod("eth_sendRawTransaction", p);
		cout << "tx send result : " << result.asString() << endl;

	}

	Json::Value eth_getWork() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_getWork", p);
		if (result.isArray())
			return result;
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	void eth_getWork_token(bytes& _challenge, h256& _target) throw (jsonrpc::JsonRpcException) {
		// challenge
		Json::Value p;
		p["from"] = MINER_ACCOUNT;			// ETH address (Jaxx HD)
		p["to"] = TOKEN_CONTRACT;			// 0xbitcoin contract address
		h256 bMethod = sha3("getChallengeNumber()");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			_challenge = fromHex(result.asString());
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

		// target
		bMethod = sha3("getMiningTarget()");
		sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		data.clear();
		data.append(p);
		data.append("latest");

		result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			_target = h256(result.asString());
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

	}

	void testHash(h256 nonce, bytes challenge)  throw (jsonrpc::JsonRpcException) {
		std::vector<byte> mix(84);
		std::ostringstream ss;
		Json::Value p;
		p["from"] = MINER_ACCOUNT;		// ETH address (Jaxx HD)
		p["to"] = TOKEN_CONTRACT;		// 0xbitcoin contract address

		// function signature
		h256 bMethod = sha3("getMintDigest(uint256,bytes32)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);

		// nonce
		ss << std::setw(64) << std::setfill('0') << nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		memcpy(&mix[52], nonce.data(), 32);

		// challenge_number
		ss = std::ostringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(challenge);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;

		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			LogS << "test hash";
			LogS << result.asString();

			h160 sender(MINER_ACCOUNT);
			memcpy(&mix[0], challenge.data(), 32);
			memcpy(&mix[32], sender.data(), 20);
			bytes hash(32);
			SHA3_256((const ethash_h256_t*) hash.data(), (const uint8_t*) mix.data(), 84);
			LogS << "0x" << toHex(hash);
			LogS << "end test";

		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitWork(const std::string& param1, const std::string& param2, const std::string& param3) throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p.append(param1);
		p.append(param2);
		p.append(param3);
		Json::Value result = this->CallMethod("eth_submitWork", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitWorkToken(h256 _nonce, bytes _hash) throw (jsonrpc::JsonRpcException) {

		// get transaction count for nonce
		Json::Value p;
		p.append(MINER_ACCOUNT);
		p.append("latest");
		Json::Value result = this->CallMethod("eth_getTransactionCount", p);
		std::istringstream converter(result.asString());
		int nonce;
		converter >> std::hex >> nonce;

		// prepare transaction
		Transaction t;
		t.nonce = nonce;
		t.receiveAddress = toAddress(TOKEN_CONTRACT);
		t.gas = u256(200000);
		t.gasPrice = u256(10000000000);

		// compute data parameter : first 4 bytes is hash of function signature
		h256 bMethod = sha3("mint(uint256,bytes32)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);
		// put the nonce in
		stringstream ss;
		ss << std::setw(64) << std::setfill('0') << _nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		// and the hash
		ss = std::stringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(_hash);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;
		t.data = fromHex(sMethod);
		t.value = 0;

		Secret pk = Secret("d1ced27471f165c1d42b2e225c416125fa998900a2865b2168686c34e5520e24");
		t.sign(pk);
		ss = std::stringstream();
		ss << "0x" << toHex(t.rlp());

		// submit to the node 
		p.clear();
		p.append(ss.str());
		//LogS << "Raw transaction to send : " << ss.str();
		result = this->CallMethod("eth_sendRawTransaction", p);
		cout << "tx send result : " << result.asString() << endl;
		return true;
	}

	void eth_checkWorkToken(h256 _nonce, bytes _challenge, bytes _hash, h256 _target) {
		// this calls the mint(nonce, challenge) function using eth_call so it can check the return result
		std::ostringstream ss;
		Json::Value p;
		p["from"] = MINER_ACCOUNT;		// ETH address (Jaxx HD)
		p["to"] = TOKEN_CONTRACT;		// 0xbitcoin contract address

		// function signature
		h256 bMethod = sha3("mint(uint256,bytes32)");
		//h256 bMethod = sha3("checkMintSolution(uint256,bytes32,bytes32,uint256)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10); 

		// nonce
		ss << std::setw(64) << std::setfill('0') << _nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;

		// hash
		ss = std::ostringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(_hash);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;

		// challenge_number
		//ss = std::ostringstream();
		//ss << std::left << std::setw(64) << std::setfill('0') << toHex(_challenge);
		//s2 = std::string(ss.str());
		//sMethod = sMethod + s2;

		// target  (this is for checkMintSolution only)
		//ss = std::ostringstream();
		//ss << std::setw(64) << std::setfill('0') << _target.hex();
		//s2 = std::string(ss.str());
		//sMethod = sMethod + s2;


		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			LogS << "mint() returns : " << result.asString();
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitHashrate(const std::string& param1, const std::string& param2) throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p.append(param1);
		p.append(param2);
		Json::Value result = this->CallMethod("eth_submitHashrate", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	Json::Value eth_awaitNewWork() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_awaitNewWork", p);
		if (result.isArray())
			return result;
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_progress() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_progress", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

};

#endif //JSONRPC_CPP_STUB_FARMCLIENT_H_
